@* Add this as a page with a href *@
@page "/fileInput"
@using System.Text.RegularExpressions
@rendermode InteractiveServer

@* 14:25 - Alex Purser: Gg 28/05/2025, 14:25 - Alex Purser: Vg 28/05/2025, *@
@* Format: *@
@* [time] - [name]: [message] [date], *@


<PageTitle>File Input</PageTitle>

<h1>Input File</h1>


@* Input button, loads function, only accepts .txt *@
<InputFile OnChange="LoadFile" accept=".txt" />


@* If a file exists, display its information *@
@if (file != null)
{
    <h3>File information:</h3>
    <ul>
        <li>Name: @file?.Name</li>
        <li>Last modified: @file?.LastModified.ToString()</li>
        <li>Size (bytes): @file?.Size</li>
        <li>Content type: @file?.ContentType</li>
    </ul>
    <p>-------------------------------------------------------------------</p>
    @if (!allFiltered)
    {
        <p><em>Loading...</em></p>
        @* <p><em>Loading... @statusMessage</em></p> *@
    }
    else
    {
        <h3>Message information: </h3>
        <ul>
            <li>Total messages: @filteredMessages.Count</li>
            <li>Participant length: @participants.Count</li>
            <li>Participants:</li>
            <ul>
                @foreach (string user in participants)
                {
                    <li>@user</li>
                }
            </ul>
            <li>Top 10 Messages:</li>
            <ol>
                @foreach (entryCount word in topMessages)
                {
                    <li>@word.Content: @word.Count</li>
                }
            </ol>
            <li>Most chatty:</li>
            <ol>
                @foreach (entryCount sender in topSenders)
                {
                    <li>@sender.Content: @sender.Count</li>
                }
            </ol>
            <li>Top 10 emojis:</li>
            <ol>
                @foreach (entryCount emoji in topEmojis)
                {
                    <li>@emoji.Content: @emoji.Count</li>
                }
            </ol>
            <li>Messages per time:</li>
            <ol>
                @foreach (entryCount time in times)
                {
                    <li>@time.Content:00 : @time.Count</li>
                }
            </ol>
            <li>Earliest message: @filteredMessages.Count</li>
            <li>Latest messages: @filteredMessages.Count</li>
        </ul>


        <h4>All messages rendered!</h4>
        @* Limit / hide this to boost performance *@
        @* <h4>All messages: </h4>
        @foreach (messageFormat message in filteredMessages)
        {
            <li>
                <ul>
                    <li>Date: @message?.Date</li>
                    <li>Time: @message?.Time</li>
                    <li>Sender: @message?.Sender</li>
                    <li>Message: @message?.Content</li>
                </ul>
            </li>
        } *@
    }
}





@* Code block for writing C# *@
@code {

    private string statusMessage = "";
    private List<string> participants = new List<string> { };
    private List<entryCount> topMessages = new List<entryCount> { };
    private List<entryCount> topEmojis = new List<entryCount> { };
    private List<entryCount> times = new List<entryCount> { };
    private List<entryCount> topSenders = new List<entryCount> { };

    public class messageFormat
    {
        public string Date = "";
        public string Time = "";
        public string Sender = "";
        public string Content = "";
    }

    public class entryCount
    {
        public string Content = "";
        public int Count = 0;
    }

    private IBrowserFile? file;
    private string content = "";

    private List<messageFormat> filteredMessages = new List<messageFormat> { };
    private bool allFiltered = false;


    private async Task LoadFile(InputFileChangeEventArgs e)
    {
        // Reset page
        allFiltered = false;

        // Extract the file
        file = e.File;

        // Open the text file using a stream reader (5MB limit).
        var fileStream = file.OpenReadStream(maxAllowedSize: 5 * 1024 * 1024);
        var reader = new StreamReader(fileStream);

        // Read the stream as a string.
        string fileContent = await reader.ReadToEndAsync();

        // Assign to global content variable
        content = fileContent;
        @* statusMessage = "file loaded"; *@
        await SplitContent(fileContent);
    }



    // Split the content into individual messages
    private async Task SplitContent(string fileContent)
    {

        // Declare regex
        string pattern = @"(?=\d{2}/\d{2}/\d{4}, \d{2}:\d{2} - )";

        // Split fileContent using the regex
        List<string> allMessages = Regex.Split(fileContent, pattern)
        .Where(message => !string.IsNullOrEmpty(message))
        .ToList();


        // For each message, filter and add to list
        foreach (string message in allMessages)
        {
            messageFormat filtered = await FilterMessages(message);
            filteredMessages.Add(filtered);
            @* if (filteredMessages.Count % 1000 == 0 || filteredMessages.Count == allMessages.Count){
                statusMessage = ((filteredMessages.Count).ToString() + "/" + (allMessages.Count).ToString());
            } *@
        }

        await MessageStats();
        allFiltered = true;
    }


    // Filter the messages into their components
    private async Task<messageFormat> FilterMessages(string message)
    {

        // Split the message into parts in a regex
        string pattern = @"^(?<date>\d{2}/\d{2}/\d{4}), (?<time>\d{2}:\d{2}) - (?<sender>.*?): (?<content>.*)";


        // Check if the message matches the regex
        var match = new Regex(pattern).Match(message);


        // Apply each string to the correct object element
        messageFormat filtered = new messageFormat
        {
            Date = match.Groups["date"].Value,
            Time = match.Groups["time"].Value,
            Sender = match.Groups["sender"].Value,
            Content = match.Groups["content"].Value,
        };

        return filtered;
    }

    // Filter the messages into their components
    private async Task MessageStats()
    {

        // Find unique participants and save as list
        participants = filteredMessages
        .Where(m => !string.IsNullOrEmpty(m.Sender))
        .Select(m => m.Sender)
        .Distinct()
        .ToList();

        // first interaction (first message and response)

        // activity per month

        // activity per time of day

        times = filteredMessages
        .Where(message => !string.IsNullOrEmpty(message.Time.Split(':')[0]))
        .GroupBy(message => message.Time.Split(':')[0])
        .Select(grp => new entryCount { Content = grp.Key, Count = grp.Count() })
        .OrderByDescending(grp => grp.Content)
        .ToList();

        // most curious (look for ?)


        // top 10 words (duplicates present: "yeah" and "Yeah")
        topMessages = filteredMessages
        // Filters
        .Where(message => !string.IsNullOrEmpty(message.Content))
        .Where(message => message.Content != "<Media omitted>")
        // Group and select order (toLower to reduce duplicates)
        .GroupBy(message => message.Content.ToLower())
        .Select(grp => new entryCount { Content = grp.Key, Count = grp.Count() })
        .OrderByDescending(grp => grp.Count)
        // Select top 10
        .Take(10)
        .ToList();


        // person who sent the most
        topSenders = filteredMessages
        .Where(message => !string.IsNullOrEmpty(message.Sender))
        .GroupBy(message => message.Sender)
        .Select(grp => new entryCount { Content = grp.Key, Count = grp.Count() })
        .OrderByDescending(grp => grp.Count)
        .ToList();


        // Most sent emoji
        string emojiRegex = @"\p{So}|\p{Cs}\p{Cs}(\p{Cf}\p{Cs}\p{Cs})*";

        List<string> emojis = new List<string>();


        // for each message
        foreach (messageFormat message in filteredMessages)
        {
            // Check if the emoji matches the regex
            var matches = Regex.Matches(message.Content, emojiRegex);

            // for every match, add to list
            foreach (Match match in matches)
            {
                emojis.Add(match.Value);
            }
        }



        // top 10 words (duplicates present: "yeah" and "Yeah")
        topEmojis = emojis
        // Group and select order (toLower to reduce duplicates)
        .GroupBy(emoji => emoji)
        .Select(grp => new entryCount { Content = grp.Key, Count = grp.Count() })
        .OrderByDescending(grp => grp.Count)
        // Select top 10
        .Take(10)
        .ToList();
    }
}
