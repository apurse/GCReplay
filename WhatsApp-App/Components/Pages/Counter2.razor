@* Add this as a page with a href *@
@page "/fileInput"
@using System.Text.RegularExpressions
@rendermode InteractiveServer
@using BlazorBootstrap

@* 14:25 - Alex Purser: Gg 28/05/2025, 14:25 - Alex Purser: Vg 28/05/2025, *@
@* Format: *@
@* [time] - [name]: [message] [date], *@


<PageTitle>File Input</PageTitle>

<h1>Input File</h1>


@* Input button, loads function, only accepts .txt *@
<InputFile OnChange="LoadFile" accept=".txt" />

<PieChart @ref="pieChart" Width="500" />



@* If a file exists, display its information *@
@if (file != null)
{
    <h3>File information:</h3>
    <ul>
        <li>Name: @file?.Name</li>
        <li>Last modified: @file?.LastModified.ToString()</li>
        <li>Size (bytes): @file?.Size</li>
        <li>Content type: @file?.ContentType</li>
    </ul>
    <p>-------------------------------------------------------------------</p>
    @if (!allFiltered)
    {
        <p><em>Loading...</em></p>
        @* <p><em>Loading... @statusMessage</em></p> *@
    }
    else
    {
        <h3>Message information: </h3>
        <ul>
            <li>Total messages: @filteredMessages.Count</li>
            <li>Participant length: @participants.Count</li>

            @* There must be a way to optimise this *@
            <li>Participants:</li>
            <ul>
                @foreach (string user in participants)
                {
                    <li>@user</li>
                }
            </ul>

            <li>Top 10 Messages:</li>
            <ol>
                @foreach (entryCount entry in topMessages)
                {
                    <li @onclick="(() => DisplayFiltered(entry.Content))">@entry.Content: @entry.Count</li>
                }
            </ol>
            <li>Most chatty:</li>
            <ol>
                @foreach (entryCount entry in topSenders)
                {
                    <li @onclick="(() => DisplayFiltered(entry.Content))">@entry.Content: @entry.Count</li>
                }
            </ol>
            <li>Top 10 emojis:</li>
            <ol>
                @foreach (entryCount entry in topEmojis)
                {
                    <li @onclick="(() => DisplayFiltered(entry.Content))">@entry.Content: @entry.Count</li>
                }
            </ol>
            <li>Messages per hour:</li>
            <ul>
                @foreach (entryCount entry in hours)
                {
                    <li @onclick="(() => DisplayFiltered(entry.Content))">@entry.Content:00 : @entry.Count</li>

                }
            </ul>
            <li>Messages per minute:</li>
            <ul>
                @foreach (entryCount entry in minutes)
                {
                    <li @onclick="(() => DisplayFiltered(entry.Content))">00:@entry.Content: @entry.Count</li>

                }
            </ul>
            <li>Messages per month day:</li>
            <ul>
                @foreach (entryCount entry in monthDays)
                {
                    <li @onclick="(() => DisplayFiltered(entry.Content))">@entry.Content: @entry.Count</li>
                }
            </ul>
            <li>Messages per month:</li>
            <ul>
                @foreach (entryCount entry in months)
                {
                    <li @onclick="(() => DisplayFiltered(entry.Content))">@entry.Content: @entry.Count</li>
                }
            </ul>
            <li>Messages per year:</li>
            <ul>
                @foreach (entryCount entry in years)
                {
                    <li @onclick="(() => DisplayFiltered(entry.Content))">@entry.Content: @entry.Count</li>
                }
            </ul>
            <li>Messages per weekday:</li>
            <ul>
                @foreach (entryCount entry in weekdays)
                {
                    <li @onclick="(() => DisplayFiltered(entry.Content))">@entry.Content: @entry.Count</li>
                }
            </ul>
            <li>Earliest message: @filteredMessages.Count</li>
            <li>Latest messages: @filteredMessages.Count</li>
        </ul>


        <h4>All messages rendered!</h4>
        @* Limit / hide this to boost performance *@
        @* <h4>All messages: </h4>
        @foreach (messageFormat message in filteredMessages)
        {
            <li>
                <ul>
                    <li>Date: @message?.Date</li>
                    <li>Time: @message?.Time</li>
                    <li>Sender: @message?.Sender</li>
                    <li>Message: @message?.Content</li>
                </ul>
            </li>
        } *@

        if (clickedMessages == null)
        {
            <p>Please select an entry to view all entries!</p>
        }
        else
        {
            @foreach (messageFormat message in clickedMessages)
            {
                <li>
                    <ul>
                        <li>Date: @message?.Date</li>
                        <li>Time: @message?.Time</li>
                        <li>Sender: @message?.Sender</li>
                        <li>Message: @message?.Content</li>
                    </ul>
                </li>
            }
        }
    }
}





@* Code block for writing C# *@
@code {

    private PieChart pieChart = default!;

    private PieChartOptions pieChartOptions = default!;
    private ChartData chartData = default!;
    private string[]? backgroundColors;

    private int datasetsCount = 0;
    private int dataLabelsCount = 0;

    private Random random = new();

    protected override void OnInitialized()
    {
        backgroundColors = ColorUtility.CategoricalTwelveColors;
        chartData = new ChartData { Labels = GetDefaultDataLabels(4), Datasets = GetDefaultDataSets(1) };

        pieChartOptions = new();
        pieChartOptions.Responsive = true;
        pieChartOptions.Plugins.Title!.Text = "2022 - Sales";
        pieChartOptions.Plugins.Title.Display = true;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await pieChart.InitializeAsync(chartData, pieChartOptions);
        }
        await base.OnAfterRenderAsync(firstRender);
    }
    private async Task RandomizeAsync()
    {
        if (chartData is null || chartData.Datasets is null || !chartData.Datasets.Any()) return;

        var newDatasets = new List<IChartDataset>();

        foreach (var dataset in chartData.Datasets)
        {
            if (dataset is PieChartDataset pieChartDataset
                && pieChartDataset is not null
                && pieChartDataset.Data is not null)
            {
                var count = pieChartDataset.Data.Count;

                var newData = new List<double?>();
                for (var i = 0; i < count; i++)
                {
                    newData.Add(random.Next(0, 100));
                }

                pieChartDataset.Data = newData;
                newDatasets.Add(pieChartDataset);
            }
        }

        chartData.Datasets = newDatasets;

        await pieChart.UpdateAsync(chartData, pieChartOptions);
    }

    private async Task AddDatasetAsync()
    {
        if (chartData is null || chartData.Datasets is null) return;

        var chartDataset = GetRandomPieChartDataset();
        chartData = await pieChart.AddDatasetAsync(chartData, chartDataset, pieChartOptions);
    }

    private async Task AddDataAsync()
    {
        if (dataLabelsCount >= 12)
            return;

        if (chartData is null || chartData.Datasets is null)
            return;

        var data = new List<IChartDatasetData>();
        foreach (var dataset in chartData.Datasets)
        {
            if (dataset is PieChartDataset pieChartDataset)
                data.Add(new PieChartDatasetData(pieChartDataset.Label, random.Next(0, 100), backgroundColors![dataLabelsCount]));
        }

        chartData = await pieChart.AddDataAsync(chartData, GetNextDataLabel(), data);

        dataLabelsCount += 1;
    }

    #region Data Preparation

    private List<IChartDataset> GetDefaultDataSets(int numberOfDatasets)
    {
        var datasets = new List<IChartDataset>();

        for (var index = 0; index < numberOfDatasets; index++)
        {
            datasets.Add(GetRandomPieChartDataset());
        }

        return datasets;
    }

    private PieChartDataset GetRandomPieChartDataset()
    {
        datasetsCount += 1;
        return new() { Label = $"Team {datasetsCount}", Data = GetRandomData(), BackgroundColor = GetRandomBackgroundColors() };
    }

    private List<double?> GetRandomData()
    {
        var data = new List<double?>();
        for (var index = 0; index < dataLabelsCount; index++)
        {
            data.Add(random.Next(0, 100));
        }

        return data;
    }

    private List<string> GetRandomBackgroundColors()
    {
        var colors = new List<string>();
        for (var index = 0; index < dataLabelsCount; index++)
        {
            colors.Add(backgroundColors![index]);
        }

        return colors;
    }

    private List<string> GetDefaultDataLabels(int numberOfLabels)
    {
        var labels = new List<string>();
        for (var index = 0; index < numberOfLabels; index++)
        {
            labels.Add(GetNextDataLabel());
            dataLabelsCount += 1;
        }

        return labels;
    }

    private string GetNextDataLabel() => $"Product {dataLabelsCount + 1}";

    private string GetNextDataBackgrounfColor() => backgroundColors![dataLabelsCount];

    #endregion  Data Preparation




    private string statusMessage = "";

    private List<List<entryCount>> AllLists = new List<List<entryCount>> { };


    // Participants
    private List<string> participants = new List<string> { };
    private List<entryCount> topSenders = new List<entryCount> { };


    // Top messages
    private List<entryCount> topMessages = new List<entryCount> { };
    private List<entryCount> topEmojis = new List<entryCount> { };


    // Time values
    private List<entryCount> hours = new List<entryCount> { };
    private List<entryCount> minutes = new List<entryCount> { };


    // Date values
    private List<entryCount> months = new List<entryCount> { };
    private List<entryCount> monthDays = new List<entryCount> { };
    private List<entryCount> years = new List<entryCount> { };
    private List<entryCount> weekdays = new List<entryCount> { };


    public class messageFormat
    {
        public string Date = "";
        public string Time = "";
        public string Sender = "";
        public string Content = "";
    }

    public class entryCount
    {
        public string Content = "";
        public int Count = 0;
    }

    private IBrowserFile? file;
    private string content = "";

    private List<messageFormat> filteredMessages = new List<messageFormat> { };
    private List<messageFormat> clickedMessages = new List<messageFormat> { };
    private bool allFiltered = false;


    private async Task LoadFile(InputFileChangeEventArgs e)
    {
        // Reset page
        allFiltered = false;

        // Extract the file
        file = e.File;

        // Open the text file using a stream reader (5MB limit).
        var fileStream = file.OpenReadStream(maxAllowedSize: 5 * 1024 * 1024);
        var reader = new StreamReader(fileStream);

        // Read the stream as a string.
        string fileContent = await reader.ReadToEndAsync();

        // Assign to global content variable
        content = fileContent;
        @* statusMessage = "file loaded"; *@
        await SplitContent(fileContent);
    }



    // Split the content into individual messages
    private async Task SplitContent(string fileContent)
    {

        // Declare regex
        string pattern = @"(?=\d{2}/\d{2}/\d{4}, \d{2}:\d{2} - )";

        // Split fileContent using the regex
        List<string> allMessages = Regex.Split(fileContent, pattern)
        .Where(message => !string.IsNullOrEmpty(message))
        .ToList();


        // For each message, filter and add to list
        foreach (string message in allMessages)
        {
            messageFormat filtered = await FilterMessages(message);
            filteredMessages.Add(filtered);
            @* if (filteredMessages.Count % 1000 == 0 || filteredMessages.Count == allMessages.Count){
                statusMessage = ((filteredMessages.Count).ToString() + "/" + (allMessages.Count).ToString());
            } *@
        }

        await MessageStats();

        @* var selectedOptions = new List<List<entryCount>> { topSenders, topEmojis, topMessages, hours, minutes, months,
monthDays, years };


        foreach (List<entryCount> entry in selectedOptions)
        {
            AllLists.Add(entry);
        } *@
        allFiltered = true;
    }


    // Filter the messages into their components
    private async Task<messageFormat> FilterMessages(string message)
    {

        // Split the message into parts in a regex
        string pattern = @"^(?<date>\d{2}/\d{2}/\d{4}), (?<time>\d{2}:\d{2}) - (?<sender>.*?): (?<content>.*)";


        // Check if the message matches the regex
        var match = new Regex(pattern).Match(message);


        // Apply each string to the correct object element
        messageFormat filtered = new messageFormat
        {
            Date = match.Groups["date"].Value,
            Time = match.Groups["time"].Value,
            Sender = match.Groups["sender"].Value,
            Content = match.Groups["content"].Value,
        };

        return filtered;
    }

    // Filter the messages into their components
    private async Task MessageStats()
    {

        // Get date data
        monthDays = await GetDateInformation("dd", filteredMessages);
        months = await GetDateInformation("MM", filteredMessages);
        years = await GetDateInformation("yyyy", filteredMessages);


        // Get time date
        hours = await GetTimeValues("HH", filteredMessages);
        minutes = await GetTimeValues("mm", filteredMessages);


        // Get the weekdays
        weekdays = filteredMessages
        .Where(message => !string.IsNullOrEmpty(message.Date))
        .GroupBy(message =>
        DateTime.ParseExact(message.Date, "dd/MM/yyyy",
        System.Globalization.CultureInfo.InvariantCulture).DayOfWeek.ToString())
        .Select(grp => new entryCount { Content = grp.Key, Count = grp.Count() })
        .ToList();


        // Find unique participants and save as list
        participants = filteredMessages
        .Where(m => !string.IsNullOrEmpty(m.Sender))
        .Select(m => m.Sender)
        .Distinct()
        .ToList();

        // first interaction (first message and response)




        // activity per hour of day
        hours = filteredMessages
        .Where(message => !string.IsNullOrEmpty(message.Time.Split(':')[0]))
        .GroupBy(message => message.Time.Split(':')[0])
        .Select(grp => new entryCount { Content = grp.Key, Count = grp.Count() })
        .OrderByDescending(grp => grp.Content)
        .ToList();

        // most curious (look for ?)


        // top 10 words (duplicates present: "yeah" and "Yeah")
        topMessages = filteredMessages
        // Filters
        .Where(message => !string.IsNullOrEmpty(message.Content))
        .Where(message => message.Content != "<Media omitted>")
        // Group and select order (toLower to reduce duplicates)
        .GroupBy(message => message.Content.ToLower())
        .Select(grp => new entryCount { Content = grp.Key, Count = grp.Count() })
        .OrderByDescending(grp => grp.Count)
        // Select top 10
        .Take(10)
        .ToList();


        // person who sent the most
        topSenders = filteredMessages
        .Where(message => !string.IsNullOrEmpty(message.Sender))
        .GroupBy(message => message.Sender)
        .Select(grp => new entryCount { Content = grp.Key, Count = grp.Count() })
        .OrderByDescending(grp => grp.Count)
        .ToList();


        // Most sent emoji
        string emojiRegex = @"\p{So}|\p{Cs}\p{Cs}(\p{Cf}\p{Cs}\p{Cs})*";

        List<string> emojis = new List<string>();


        // for each message
        foreach (messageFormat message in filteredMessages)
        {
            // Check if the emoji matches the regex
            var matches = Regex.Matches(message.Content, emojiRegex);

            // for every match, add to list
            foreach (Match match in matches)
            {
                emojis.Add(match.Value);
            }
        }



        // top 10 words (duplicates present: "yeah" and "Yeah")
        topEmojis = emojis
        // Group and select order
        .GroupBy(emoji => emoji)
        .Select(grp => new entryCount { Content = grp.Key, Count = grp.Count() })
        .OrderByDescending(grp => grp.Count)
        // Select top 10
        .Take(10)
        .ToList();
    }


    // Get activity based on the date values.
    // @param option | the date option ("dd" "MM" "yyyy")
    // @param messages | the list of messages
    private async Task<List<entryCount>> GetDateInformation(string option, List<messageFormat> messages)
    {
        var dateValues = messages

        // Check if its empty
        .Where(message => !string.IsNullOrEmpty(message.Date))

        // Parse date and extract using the selected option
        .GroupBy(message =>
        DateTime.ParseExact(message.Date, "dd/MM/yyyy",
        System.Globalization.CultureInfo.InvariantCulture).ToString(option))

        // Add to object and organise the list
        .Select(grp => new entryCount { Content = grp.Key, Count = grp.Count() })
        .OrderByDescending(grp => grp.Content)
        .ToList();

        return dateValues;
    }


    // Get activity based on the time values.
    // @param option | the time option ("HH" "mm")
    // @param messages | the list of messages
    private async Task<List<entryCount>> GetTimeValues(string option, List<messageFormat> messages)
    {
        var timeValues = messages

        // Check if its empty
        .Where(message => !string.IsNullOrEmpty(message.Time))

        // Parse time and extract using the selected option
        .GroupBy(message =>
        DateTime.ParseExact(message.Time, "HH:mm",
        System.Globalization.CultureInfo.InvariantCulture).ToString(option))

        // Add to object and organise the list
        .Select(grp => new entryCount { Content = grp.Key, Count = grp.Count() })
        .OrderByDescending(grp => grp.Content)
        .ToList();

        return timeValues;
    }

    private async Task DisplayFiltered(string filter)
    {

        clickedMessages = filteredMessages

        // Check if its empty
        .Where(message => !string.IsNullOrEmpty(message.Time))
        .Where(message => message.Content.Contains(filter))
        .ToList();
    }


}
