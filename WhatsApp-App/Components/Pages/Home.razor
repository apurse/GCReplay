@page "/"

@* Add this as a page with a href *@
@using System.Text.RegularExpressions
@rendermode InteractiveServer
@using BlazorBootstrap

@using Components.Models
@* @using Components.Graphs *@

@* 14:25 - Alex Purser: Gg 28/05/2025, 14:25 - Alex Purser: Vg 28/05/2025, *@
@* Format: *@
@* [time] - [name]: [message] [date], *@


<PageTitle>GCReplay Home</PageTitle>

<h1>Please Input Your Desired File!</h1>


@* Input button, loads function, only accepts .txt *@
<InputFile OnChange="LoadFile" accept=".txt" />




@* If a file exists, display its information *@
@if (file != null)
{
    <h3>File information:</h3>
    <ul>
        <li>Name: @file?.Name</li>
        <li>Last modified: @file?.LastModified.ToString()</li>
        <li>Size (bytes): @file?.Size</li>
        <li>Content type: @file?.ContentType</li>
    </ul>
    <p>-------------------------------------------------------------------</p>
    @if (!allFiltered)
    {
        <p><em>Loading...</em></p>
        @* <p><em>Loading... @statusMessage</em></p> *@
    }
    else
    {
        <div class="tileContainer">

            <h3>Message information: </h3>

            <ul>
                <li>Total messages: @filteredMessages.Count</li>
                <li>Participant length: @participants.Count</li>

                @* There must be a way to optimise this *@
                <li>Participants:</li>
                <ul>
                    @foreach (string user in participants)
                    {
                        <li>@user</li>
                    }
                </ul>

                <div class="tile">
                    <li>Top 10 Messages:</li>
                    <PieChartMaker Title="Most Sent Messages" PopupLabel="Times sent" Data="@topMessages" />
                    <ol>
                        @foreach (EntryCount entry in topMessages)
                        {
                            <li @onclick="(() => DisplayFiltered(entry.Content))">@entry.Content: @entry.Count</li>
                        }
                    </ol>
                </div>

                <div class="tile">
                    <li>Most chatty:</li>
                    <PieChartMaker Title="Messages Sent per Participant" PopupLabel="Messages sent" Data="@topSenders" />
                    <ol>
                        @foreach (EntryCount entry in topSenders)
                        {
                            <li @onclick="(() => DisplayFiltered(entry.Content))">@entry.Content: @entry.Count</li>
                        }
                    </ol>
                </div>

                <div class="tile">
                    <li>Top 10 emojis:</li>
                    <PieChartMaker Title="Most Sent Emojis" PopupLabel="Times sent" Data="@topEmojis" />

                    <ol>
                        @foreach (EntryCount entry in topEmojis)
                        {
                            <li @onclick="(() => DisplayFiltered(entry.Content))">@entry.Content: @entry.Count</li>
                        }
                    </ol>
                </div>
                
                <div class="tile">
                    <li>Messages per hour:</li>
                    <ul>
                        @foreach (EntryCount entry in hours)
                        {
                            <li @onclick="(() => DisplayFiltered(entry.Content))">@entry.Content:00 : @entry.Count</li>

                        }
                    </ul>
                </div>

                <li>Messages per minute:</li>
                <ul>
                    @foreach (EntryCount entry in minutes)
                    {
                        <li @onclick="(() => DisplayFiltered(entry.Content))">00:@entry.Content: @entry.Count</li>

                    }
                </ul>
                <li>Messages per month day:</li>
                <ul>
                    @foreach (EntryCount entry in monthDays)
                    {
                        <li @onclick="(() => DisplayFiltered(entry.Content))">@entry.Content: @entry.Count</li>
                    }
                </ul>
                <li>Messages per month:</li>
                <BarGraphMaker Title="Messages per Month" XLabel="Messages" YLabel="Month" Data="@months" />

                <ul>
                    @foreach (EntryCount entry in months)
                    {
                        <li @onclick="(() => DisplayFiltered(entry.Content))">@entry.Content: @entry.Count</li>
                    }
                </ul>
                <li>Messages per year:</li>
                <ul>
                    @foreach (EntryCount entry in years)
                    {
                        <li @onclick="(() => DisplayFiltered(entry.Content))">@entry.Content: @entry.Count</li>
                    }
                </ul>
                <li>Messages per weekday:</li>
                <BarGraphMaker Title="Messages per weekday" XLabel="Messages" YLabel="Weekday" Data="@weekdays" />

                <ul>
                    @foreach (EntryCount entry in weekdays)
                    {
                        <li @onclick="(() => DisplayFiltered(entry.Content))">@entry.Content: @entry.Count</li>
                    }
                </ul>
                <li>Earliest message: @filteredMessages.Count</li>
                <li>Latest messages: @filteredMessages.Count</li>
            </ul>

        </div>


        <h4>All messages rendered!</h4>
        @* Limit / hide this to boost performance *@
        @* <h4>All messages: </h4>
        @foreach (messageFormat message in filteredMessages)
        {
            <li>
                <ul>
                    <li>Date: @message?.Date</li>
                    <li>Time: @message?.Time</li>
                    <li>Sender: @message?.Sender</li>
                    <li>Message: @message?.Content</li>
                </ul>
            </li>
        } *@

        if (clickedMessages == null)
        {
            <p>Please select an entry to view all entries!</p>
        }
        else
        {
            @foreach (messageFormat message in clickedMessages)
            {
                <li>
                    <ul>
                        <li>Date: @message?.Date</li>
                        <li>Time: @message?.Time</li>
                        <li>Sender: @message?.Sender</li>
                        <li>Message: @message?.Content</li>
                    </ul>
                </li>
            }
        }
    }
}





@* Code block for writing C# *@
@code {

    public class messageFormat
    {
        public string Date = "";
        public string Time = "";
        public string Sender = "";
        public string Content = "";
    }



    private string statusMessage = "";

    private List<List<EntryCount>> AllLists = new List<List<EntryCount>> { };


    // Participants
    private List<string> participants = new List<string> { "tesst", "test" };
    private List<EntryCount> topSenders = new List<EntryCount> { };


    // Top messages
    private List<EntryCount> topMessages = new List<EntryCount> { };
    private List<EntryCount> topEmojis = new List<EntryCount> { };


    // Time values
    private List<EntryCount> hours = new List<EntryCount> { };
    private List<EntryCount> minutes = new List<EntryCount> { };


    // Date values
    private List<EntryCount> months = new List<EntryCount> { };
    private List<EntryCount> monthDays = new List<EntryCount> { };
    private List<EntryCount> years = new List<EntryCount> { };
    private List<EntryCount> weekdays = new List<EntryCount> { };


    private IBrowserFile? file;
    private string content = "";

    private List<messageFormat> filteredMessages = new List<messageFormat> { };
    private List<messageFormat> clickedMessages = new List<messageFormat> { };
    private bool allFiltered = false;


    private async Task LoadFile(InputFileChangeEventArgs e)
    {
        // Reset page
        allFiltered = false;

        // Extract the file
        file = e.File;

        // Open the text file using a stream reader (5MB limit).
        var fileStream = file.OpenReadStream(maxAllowedSize: 5 * 1024 * 1024);
        var reader = new StreamReader(fileStream);

        // Read the stream as a string.
        string fileContent = await reader.ReadToEndAsync();

        // Assign to global content variable
        content = fileContent;
        @* statusMessage = "file loaded"; *@
        await SplitContent(fileContent);
    }



    // Split the content into individual messages
    private async Task SplitContent(string fileContent)
    {

        // Declare regex
        string pattern = @"(?=\d{2}/\d{2}/\d{4}, \d{2}:\d{2} - )";

        // Split fileContent using the regex
        List<string> allMessages = Regex.Split(fileContent, pattern)
        .Where(message => !string.IsNullOrEmpty(message))
        .ToList();


        // For each message, filter and add to list
        foreach (string message in allMessages)
        {
            messageFormat filtered = await FilterMessages(message);
            filteredMessages.Add(filtered);
            @* if (filteredMessages.Count % 1000 == 0 || filteredMessages.Count == allMessages.Count){
                statusMessage = ((filteredMessages.Count).ToString() + "/" + (allMessages.Count).ToString());
            } *@
        }

        await MessageStats();

        @* var selectedOptions = new List<List<entryCount>> { topSenders, topEmojis, topMessages, hours, minutes, months,
monthDays, years };


        foreach (List<entryCount> entry in selectedOptions)
        {
            AllLists.Add(entry);
        } *@
        allFiltered = true;
    }


    // Filter the messages into their components
    private async Task<messageFormat> FilterMessages(string message)
    {

        // Split the message into parts in a regex
        string pattern = @"^(?<date>\d{2}/\d{2}/\d{4}), (?<time>\d{2}:\d{2}) - (?<sender>.*?): (?<content>.*)";


        // Check if the message matches the regex
        var match = new Regex(pattern).Match(message);


        // Apply each string to the correct object element
        messageFormat filtered = new messageFormat
        {
            Date = match.Groups["date"].Value,
            Time = match.Groups["time"].Value,
            Sender = match.Groups["sender"].Value,
            Content = match.Groups["content"].Value,
        };

        return filtered;
    }

    // Filter the messages into their components
    private async Task MessageStats()
    {

        // Get date data
        monthDays = await GetDateInformation("dd", filteredMessages);
        months = await GetDateInformation("MM", filteredMessages);
        years = await GetDateInformation("yyyy", filteredMessages);


        // Get time date
        hours = await GetTimeValues("HH", filteredMessages);
        minutes = await GetTimeValues("mm", filteredMessages);


        // Get the weekdays
        weekdays = filteredMessages
        .Where(message => !string.IsNullOrEmpty(message.Date))
        .GroupBy(message =>
        DateTime.ParseExact(message.Date, "dd/MM/yyyy",
        System.Globalization.CultureInfo.InvariantCulture).DayOfWeek.ToString())
        .Select(grp => new EntryCount { Content = grp.Key, Count = grp.Count() })
        .ToList();


        // Find unique participants and save as list
        participants = filteredMessages
        .Where(m => !string.IsNullOrEmpty(m.Sender))
        .Select(m => m.Sender)
        .Distinct()
        .ToList();

        // first interaction (first message and response)




        // activity per hour of day
        hours = filteredMessages
        .Where(message => !string.IsNullOrEmpty(message.Time.Split(':')[0]))
        .GroupBy(message => message.Time.Split(':')[0])
        .Select(grp => new EntryCount { Content = grp.Key, Count = grp.Count() })
        .OrderByDescending(grp => grp.Content)
        .ToList();

        // most curious (look for ?)


        // top 10 words (duplicates present: "yeah" and "Yeah")
        topMessages = filteredMessages
        // Filters
        .Where(message => !string.IsNullOrEmpty(message.Content))
        .Where(message => message.Content != "<Media omitted>")
        // Group and select order (toLower to reduce duplicates)
        .GroupBy(message => message.Content.ToLower())
        .Select(grp => new EntryCount { Content = grp.Key, Count = grp.Count() })
        .OrderByDescending(grp => grp.Count)
        // Select top 10
        .Take(10)
        .ToList();


        // person who sent the most
        topSenders = filteredMessages
        .Where(message => !string.IsNullOrEmpty(message.Sender))
        .GroupBy(message => message.Sender)
        .Select(grp => new EntryCount { Content = grp.Key, Count = grp.Count() })
        .OrderByDescending(grp => grp.Count)
        .ToList();


        // Most sent emoji
        string emojiRegex = @"\p{So}|\p{Cs}\p{Cs}(\p{Cf}\p{Cs}\p{Cs})*";

        List<string> emojis = new List<string>();


        // for each message
        foreach (messageFormat message in filteredMessages)
        {
            // Check if the emoji matches the regex
            var matches = Regex.Matches(message.Content, emojiRegex);

            // for every match, add to list
            foreach (Match match in matches)
            {
                emojis.Add(match.Value);
            }
        }



        // top 10 words (duplicates present: "yeah" and "Yeah")
        topEmojis = emojis
        // Group and select order
        .GroupBy(emoji => emoji)
        .Select(grp => new EntryCount { Content = grp.Key, Count = grp.Count() })
        .OrderByDescending(grp => grp.Count)
        // Select top 10
        .Take(10)
        .ToList();
    }


    // Get activity based on the date values.
    // @param option | the date option ("dd" "MM" "yyyy")
    // @param messages | the list of messages
    private async Task<List<EntryCount>> GetDateInformation(string option, List<messageFormat> messages)
    {
        var dateValues = messages

        // Check if its empty
        .Where(message => !string.IsNullOrEmpty(message.Date))

        // Parse date and extract using the selected option
        .GroupBy(message =>
        DateTime.ParseExact(message.Date, "dd/MM/yyyy",
        System.Globalization.CultureInfo.InvariantCulture).ToString(option))

        // Add to object and organise the list
        .Select(grp => new EntryCount { Content = grp.Key, Count = grp.Count() })
        .OrderByDescending(grp => grp.Content)
        .ToList();

        return dateValues;
    }


    // Get activity based on the time values.
    // @param option | the time option ("HH" "mm")
    // @param messages | the list of messages
    private async Task<List<EntryCount>> GetTimeValues(string option, List<messageFormat> messages)
    {
        var timeValues = messages

        // Check if its empty
        .Where(message => !string.IsNullOrEmpty(message.Time))

        // Parse time and extract using the selected option
        .GroupBy(message =>
        DateTime.ParseExact(message.Time, "HH:mm",
        System.Globalization.CultureInfo.InvariantCulture).ToString(option))

        // Add to object and organise the list
        .Select(grp => new EntryCount { Content = grp.Key, Count = grp.Count() })
        .OrderByDescending(grp => grp.Content)
        .ToList();

        return timeValues;
    }

    private async Task DisplayFiltered(string filter)
    {

        clickedMessages = filteredMessages

        // Check if its empty
        .Where(message => !string.IsNullOrEmpty(message.Time))
        .Where(message => message.Content.Contains(filter))
        .ToList();
    }


}

