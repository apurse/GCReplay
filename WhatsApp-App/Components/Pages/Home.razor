@page "/"

@* Add this as a page with a href *@
@using System.Text.RegularExpressions
@rendermode InteractiveServer
@using BlazorBootstrap

@using Components.Models
@* @using Components.Graphs *@

@* 14:25 - Alex Purser: Gg 28/05/2025, 14:25 - Alex Purser: Vg 28/05/2025, *@
@* Format: *@
@* [time] - [name]: [message] [date], *@


<PageTitle>GCReplay Home</PageTitle>






@* If a file exists, display its information *@
@if (file == null)
{
    <h1>Please Input Your Desired File!</h1>


    @* Input button, loads function, only accepts .txt *@
    <InputFile OnChange="LoadFile" accept=".txt" />
}
else
{
    <h3>File information:</h3>
    <ul>
        <li>Name: @file?.Name</li>
        <li>Last modified: @file?.LastModified.ToString()</li>
        <li>Size (bytes): @file?.Size</li>
        <li>Content type: @file?.ContentType</li>
    </ul>
    <button onclick="@resetForm">Reset</button>
    <p>-------------------------------------------------------------------</p>
    @if (!allFiltered)
    {
        <p><em>Loading...</em></p>
    }
    else
    {
        <h3>Message information: </h3>

        <ul>
            <li>Total messages: @filteredMessages.Count</li>
            <li>Participant length: @participants.Count</li>
            <li>Earliest message: @filteredMessages.Count</li>
            <li>Latest messages: @filteredMessages.Count</li>


            <div class="tileContainer">

                @* Make each tile *@
                @foreach (TileData tile in AllTiles)
                {
                    <Tile Title="@tile.TileTitle" Data="@tile.Data" style="@tileColours[tileCount]" Graph="@tile.Graph" />
                    tileCount++;
                }
            </div>
        </ul>



        <h4>All messages rendered!</h4>
        @* Limit / hide this to boost performance *@
        @* <h4>All messages: </h4>
        @foreach (messageFormat message in filteredMessages)
        {
            <li>
                <ul>
                    <li>Date: @message?.Date</li>
                    <li>Time: @message?.Time</li>
                    <li>Sender: @message?.Sender</li>
                    <li>Message: @message?.Content</li>
                </ul>
            </li>
        } *@

        if (clickedMessages == null)
        {
            <p>Please select an entry to view all entries!</p>
        }
        else
        {
            @foreach (messageFormat message in clickedMessages)
            {
                <li>
                    <ul>
                        <li>Date: @message?.Date</li>
                        <li>Time: @message?.Time</li>
                        <li>Sender: @message?.Sender</li>
                        <li>Message: @message?.Content</li>
                    </ul>
                </li>
            }
        }
    }
}





@* Code block for writing C# *@
@code {

    public class messageFormat
    {
        public string Date = "";
        public string Time = "";
        public string Sender = "";
        public string Content = "";
    }



    private string statusMessage = "";

    private int tileCount = 0;

    private List<TileData> AllTiles = new List<TileData> { };


    // Participants
    private List<string> participants = new List<string> { "tesst", "test" };
    private List<EntryCount> topSenders = new List<EntryCount> { };


    // Top messages
    private List<EntryCount> topMessages = new List<EntryCount> { };
    private List<EntryCount> topEmojis = new List<EntryCount> { };


    // Time values
    private List<EntryCount> hours = new List<EntryCount> { };
    private List<EntryCount> minutes = new List<EntryCount> { };


    // Date values
    private List<EntryCount> months = new List<EntryCount> { };
    private List<EntryCount> monthDays = new List<EntryCount> { };
    private List<EntryCount> years = new List<EntryCount> { };
    private List<EntryCount> weekdays = new List<EntryCount> { };

    private List<string> tileColours = new List<string> { };


    private IBrowserFile? file;
    private string content = "";

    private List<messageFormat> filteredMessages = new List<messageFormat> { };
    private List<messageFormat> clickedMessages = new List<messageFormat> { };
    private bool allFiltered = false;


    // Create colour tiles and store in list
    private async Task<List<string>> CreateTileColours(int dataEntries)
    {
        Random r = new Random();
        List<string> colours = new List<string> { };

        // For each data entry
        for (int i = 0; i < dataEntries; i++)
        {
            // Get colours
            int red = r.Next(0, 100);
            int green = r.Next(0, 100);
            int blue = r.Next(0, 100);

            // Background colour

            string backgroundColour = $"rgb({red}, {green}, {blue})";

            // Border colour (set opacity)
            string borderColour = $"rgba({red}, {green}, {blue}, 0.5)";

            // Combine into style
            string style = $"background-color: {backgroundColour}; border-color: {borderColour};";


            colours.Add(style);
        }


        return colours;
    }


    private async Task LoadFile(InputFileChangeEventArgs e)
    {

        // Create colours for the tiles
        tileColours = await CreateTileColours(11);


        // Extract the file
        file = e.File;

        // Open the text file using a stream reader (5MB limit).
        var fileStream = file.OpenReadStream(maxAllowedSize: 5 * 1024 * 1024);
        var reader = new StreamReader(fileStream);

        // Read the stream as a string
        string fileContent = await reader.ReadToEndAsync();

        // Split the content
        await SplitContent(fileContent);
    }



    // Split the content into individual messages
    private async Task SplitContent(string fileContent)
    {

        // Declare regex
        string pattern = @"(?=\d{2}/\d{2}/\d{4}, \d{2}:\d{2} - )";

        // Split fileContent using the regex
        List<string> allMessages = Regex.Split(fileContent, pattern)
        .Where(message => !string.IsNullOrEmpty(message))
        .ToList();


        // For each message, filter and add to list
        foreach (string message in allMessages)
        {
            messageFormat filtered = await FilterMessages(message);
            filteredMessages.Add(filtered);
        }

        await MessageStats();

        allFiltered = true;
    }


    // Filter the messages into their components
    private async Task<messageFormat> FilterMessages(string message)
    {

        // Split the message into parts in a regex
        string pattern = @"^(?<date>\d{2}/\d{2}/\d{4}), (?<time>\d{2}:\d{2}) - (?<sender>.*?): (?<content>.*)";


        // Check if the message matches the regex
        var match = new Regex(pattern).Match(message);


        // Apply each string to the correct object element
        messageFormat filtered = new messageFormat
        {
            Date = match.Groups["date"].Value,
            Time = match.Groups["time"].Value,
            Sender = match.Groups["sender"].Value,
            Content = match.Groups["content"].Value,
        };

        return filtered;
    }

    // Filter the messages into their components
    private async Task MessageStats()
    {

        // Get date data
        monthDays = await GetDateInformation("dd", filteredMessages);
        months = await GetDateInformation("MM", filteredMessages);
        years = await GetDateInformation("yyyy", filteredMessages);


        // Get time date
        hours = await GetTimeValues("HH", filteredMessages);
        minutes = await GetTimeValues("mm", filteredMessages);


        // Get the weekdays
        weekdays = filteredMessages
        .Where(message => !string.IsNullOrEmpty(message.Date))
        .GroupBy(message =>
        DateTime.ParseExact(message.Date, "dd/MM/yyyy",
        System.Globalization.CultureInfo.InvariantCulture).DayOfWeek.ToString())
        .Select(grp => new EntryCount { Content = grp.Key, Count = grp.Count() })
        .ToList();


        // Find unique participants and save as list
        participants = filteredMessages
        .Where(m => !string.IsNullOrEmpty(m.Sender))
        .Select(m => m.Sender)
        .Distinct()
        .ToList();

        // first interaction (first message and response)




        // activity per hour of day
        hours = filteredMessages
        .Where(message => !string.IsNullOrEmpty(message.Time.Split(':')[0]))
        .GroupBy(message => message.Time.Split(':')[0])
        .Select(grp => new EntryCount { Content = grp.Key, Count = grp.Count() })
        .OrderByDescending(grp => grp.Content)
        .ToList();

        // most curious (look for ?)


        // top 10 words (duplicates present: "yeah" and "Yeah")
        topMessages = filteredMessages
        // Filters
        .Where(message => !string.IsNullOrEmpty(message.Content))
        .Where(message => message.Content != "<Media omitted>")
        // Group and select order (toLower to reduce duplicates)
        .GroupBy(message => message.Content.ToLower())
        .Select(grp => new EntryCount { Content = grp.Key, Count = grp.Count() })
        .OrderByDescending(grp => grp.Count)
        // Select top 10
        .Take(10)
        .ToList();


        // person who sent the most
        topSenders = filteredMessages
        .Where(message => !string.IsNullOrEmpty(message.Sender))
        .GroupBy(message => message.Sender)
        .Select(grp => new EntryCount { Content = grp.Key, Count = grp.Count() })
        .OrderByDescending(grp => grp.Count)
        .ToList();


        // Most sent emoji
        string emojiRegex = @"\p{So}|\p{Cs}\p{Cs}(\p{Cf}\p{Cs}\p{Cs})*";
        List<string> emojis = new List<string>();

        // for each message
        foreach (messageFormat message in filteredMessages)
        {
            // Check if the emoji matches the regex
            var matches = Regex.Matches(message.Content, emojiRegex);

            // for every match, add to list
            foreach (Match match in matches)
            {
                emojis.Add(match.Value);
            }
        }

        topEmojis = emojis
        .GroupBy(emoji => emoji)
        .Select(grp => new EntryCount { Content = grp.Key, Count = grp.Count() })
        .OrderByDescending(grp => grp.Count)
        .Take(10)
        .ToList();



        // Manually add each tile entry
        AllTiles.Add(new()
        {
            TileTitle = "Messages Sent per Person",
            Data = topSenders,
            Graph = new() { GraphType = "pie", GraphTitle = "Messages Sent", PopupLabel = "Sent" }
        });

        AllTiles.Add(new()
        {
            TileTitle = "Top Emojis",
            Data = topEmojis,
            Graph = new() { GraphType = "pie", GraphTitle = "Emojis sent", PopupLabel = "Sent" }
        });

        AllTiles.Add(new()
        {
            TileTitle = "Top 10 messages",
            Data = topMessages,
            Graph = new() { GraphType = "pie", GraphTitle = "Top 10 Messages", PopupLabel = "Messages Sent" }
        });

        AllTiles.Add(new()
        {
            TileTitle = "Messages per hour",
            Data = hours,
            Graph = new() { GraphType = "bar", GraphTitle = "Emojis sent", XLabel = "Messages Sent", YLabel = "Month" }
        });
        AllTiles.Add(new()

        {
            TileTitle = "Messages per minute",
            Data = minutes,
            Graph = new() { GraphType = "bar", GraphTitle = "Emojis sent", XLabel = "Messages Sent", YLabel = "Month" }
        });
        AllTiles.Add(new()

        {
            TileTitle = "Messages per year",
            Data = years,
            Graph = new() { GraphType = "bar", GraphTitle = "Emojis sent", XLabel = "Messages Sent", YLabel = "Month" }
        });

        AllTiles.Add(new()
        {
            TileTitle = "Messages Sent per Month day",
            Data = monthDays,
            Graph = new() { GraphType = "bar", GraphTitle = "Emojis sent", XLabel = "Messages Sent", YLabel = "Month" }
        });

        AllTiles.Add(new()
        {
            TileTitle = "Messages Sent per week days",
            Data = weekdays,
            Graph = new() { GraphType = "bar", GraphTitle = "Emojis sent", XLabel = "Messages Sent", YLabel = "Month" }
        });
    }


    // Get activity based on the date values.
    // @param option | the date option ("dd" "MM" "yyyy")
    // @param messages | the list of messages
    private async Task<List<EntryCount>> GetDateInformation(string option, List<messageFormat> messages)
    {
        var dateValues = messages

        // Check if its empty
        .Where(message => !string.IsNullOrEmpty(message.Date))

        // Parse date and extract using the selected option
        .GroupBy(message =>
        DateTime.ParseExact(message.Date, "dd/MM/yyyy",
        System.Globalization.CultureInfo.InvariantCulture).ToString(option))

        // Add to object and organise the list
        .Select(grp => new EntryCount { Content = grp.Key, Count = grp.Count() })
        .OrderByDescending(grp => grp.Content)
        .ToList();

        return dateValues;
    }



    // Get activity based on the time values.
    // @param option | the time option ("HH" "mm")
    // @param messages | the list of messages
    private async Task<List<EntryCount>> GetTimeValues(string option, List<messageFormat> messages)
    {
        var timeValues = messages

        // Check if its empty
        .Where(message => !string.IsNullOrEmpty(message.Time))

        // Parse time and extract using the selected option
        .GroupBy(message =>
        DateTime.ParseExact(message.Time, "HH:mm",
        System.Globalization.CultureInfo.InvariantCulture).ToString(option))

        // Add to object and organise the list
        .Select(grp => new EntryCount { Content = grp.Key, Count = grp.Count() })
        .OrderByDescending(grp => grp.Content)
        .ToList();

        return timeValues;
    }



    private async Task DisplayFiltered(string filter)
    {

        clickedMessages = filteredMessages

        // Check if its empty
        .Where(message => !string.IsNullOrEmpty(message.Time))
        .Where(message => message.Content.Contains(filter))
        .ToList();
    }


    // Reset the page when pressed
    private async Task resetForm()
    {
        file = null;
        filteredMessages = new List<messageFormat> { };
        allFiltered = false;
        AllTiles = new List<TileData> { };
        tileCount = 0;
    }
}
